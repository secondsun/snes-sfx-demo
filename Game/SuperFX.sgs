.include "libSFX.i"
.include "edgeEntry.i"

;This draws tree.bin
; Tree.bin is 0x1f columns 
; Tree.bin is 4bpp data (two pixels per cell)
; Tree.bin is 0x3f rows

.segment "GSUCODE"
;lines = 0xA0
GSU_Code:
.export GSU_Code

initializeEdgeTable:
  ;set all counters to 0 in 
  cache
  iwt r12, #159
  iwt r13, #:+
  :
  ibt r0, #.sizeof(edgerow)
  umult r12
  iwt r1, #edgeTable
  to r1
  add r1
  ibt r0, #0
  stb (r1)
  loop
nop
  iwt r1, #edgeTable
  ibt r0, #0
  stb (r1)

createEdgeTable:
  ibt r0, #3 ; sprite index counter
  romb 

  ibt r5, #0 ; sprite index counter

  
  
  ;for 0 -> spritespace::count
  	iwt r0,# (spritespace + spritelist::count) ; address of number of sprites
  	to r3
  	ldb (r0) ;get number of sprites to r3
cache
    addEdgeEntry:
	; umult = r5 * r6 => [R0]
	; r5 is sprite index.
	; r6 will have size of sprite
	; spritespace + r0 => r14 which is the start of the sprite list to draw
	iwt r6, #.sizeof(sprite)
	from r6
	umult r5
	iwt r1, #(spritespace + 2)
	add r1; skip pad byte and r0 = address of address of textur
	to r14
	ldw (r0) ; r14 has address of texture and loads first byte
	
    
	; optimize we need to interleave instructions so the rom buffer can fill
	; calculate and update the count of the line index of edge entries
	;   count := (edgeTable + yLoc * sizeof(edgeentry) )
	;   yLoc = r0+3
	ibt r1, #$2
	to r1
	add r1
	to r9
	ldb (r1) ; r9 now has xLoc

	ibt r1, #$3
	to r1
	add r1
	to r6
	ldb (r1) ; r6 now has yLoc
	move r4, r6 ; r4 has yLoc
	inc r1 ; r1 + 1 = scale_rAddress
	to r13
	ldw (r1); r13 has scale_r
	inc r1 ; 
	inc r1 ; r1 + 2 = scaleAddress
	to r2
	ldw (r1); r2 has scale
	;load texture address to r0 interleaving load
	move r8, r0
	getbl
	inc r14

	ibt r7, #.sizeof(edgerow)
	with r6
	umult r7 ; r6 = yLoc* sizeof(edgerow)
	iwt r1, #edgeTable
	from r6
	to r7
	add r1; r7 = address of count
	to r6
	ldb (r7)
	to r8
	ldw(r8)
    with r8
	add #2

	getbh
;how many rows?
; r0[h] * r6
move r10, r6
move r6, r2
move r2, r10
move r10, r4
;calculate height of sprite
to r11
hib
with r11
lmult
from r4
to r11
hib	
move r4, r10


	;end interleave
    ; r0 = [h][w/2]
	; r2 = indexOfEntryOnRow (maxes out at r3, #of Sprites)
	; r6 = scale
	; r3 = #ofSprites
	; r4 = yLoc
	; r5 = spriteIndex
	; r7 = count address
	; r8 = spriteAddress
	; r9 = xLoc
	; r11 = rendered height
	; r13 = scale_r
	; r12 = lineBeingDrawn
	; r10 = scratch
	;============================
	;
	;
	;r8 = spriteAddress := {W/2 (bh), h(bl), 4bpp[]}
	;
	; r8+2 = xLoc
	; r8+3 = yLoc
	; r8+4/5 = scale
	;
    ; we need to write an edgeEntry from yLoc -> yLoc + (h*scale).
	;   each entry is ++count _pad_ entries[]{texture, xLoc, w*2*scale, scale}
	;write to count_address + 2 +  count*sizeof(edgeentry) the following {r8, r9, r0[low]*2*r6, r6}
ibt r12, #0; start with first line
addEdgeRow:
    ibt r10, #.sizeof(edgeentry) ; r10 is a scratch register
    move r1, r0 ; r1 = [h][w/2]
	move r0, r2 ; 
	from r10
	umult r2
	add #2
	add r7 ; r0 is now the address to write the row

	;begin calculate row of texture to read from on this line
    move r10, r6
	move r6, r12
	move r12, r10 ; swap r6 and r 12

	from r1
	to r10
	lob ; r10 = with/2 aka #of bytes
	with r10	
	swap ; r10 = w/2.8 fixed
	with r10
	fmult ; r10 = scaled texture offset

	from r8 ; base address
	to r10 
	add r10 ; r10 = r8 + scaledOffset
	from r10
	stw (r0) ; texture start address scaled 
	
	move r10, r6
	move r6, r12
	move r12, r10 ; swap r6 and r12 back

	add #2
	from r9
	stb (r0) ; xloc

	add #1
	from r1
	to r10
	lob
	with r10
	swap
	with r10
	rol ; r10 = w.8

	with r10
	fmult 
	
	from r10
	stb (r0) ; width

	add #1
	from r13
	stw (r0) ; scale_r/2 (pixels are stored 2 per byte so when we draw a line we only want to travel half as far)
	inc r2
	from r2
	stb (r7) ; count++
    move r0, r1
	; fetch next row and count
	iwt r10, #.sizeof(edgerow)
	with r7
	add r10
	to r2
	ldb (r7)
	dec r11
	with r12
	add r13
	bne addEdgeRow
	nop
	; this writes one edge row entry 

	; for 0 -> sprite height * scale
  	;   addEdgeEntry (sprite, startX, scale)
  	; end

	inc r5
	from r3
	sub r5
	branch:
	beq next
	nop
	iwt r15, #addEdgeEntry
	nop
  	;TODO subtracing spriteIndex - spriteCount and branching if the index is past the count may be faster by 1 - 2cycles
  	
next:
  ;end 
  
  

  iwt r0, #edgeTable
  iwt r12, #160 ;160 rows in table
  iwt r13, #drawEdgeTable
  ibt r2, #0
  cache
drawEdgeTable:
  ibt r1, #0 ; x = 0;
  to r3
  ldb (r0) ; read count
  with r3
  add #0 ; set flags
  bne drawLine ; if count != 0 then draw the edge lines, else draw transparent
	nop
	move r3, r0 ; backup memory location

	ibt r0, #$3 ; transparency off, high nibble has color
	cmode 
	ibt r0, #0 ; set color to black
	color
   
	ibt r0, #$20 ; 128 pixel 
	drawFour: 
	  plot
	  plot
	  plot
	  plot
	  dec r0
      bne drawFour
	  nop
	  move r0, r3;restore edge table loc
	  ibt r3, #.sizeof(edgerow)
	  add r3
	loop ; loop back to drawEdgeTable
	inc r2
	bra finish
	nop
  ; above if there are no sprites, draw a black line
  ; below draw the black preamble, then sprites (and fill gaps with black), then end black
  
  drawLine: 
  	add #2 ; r0 points to first edge entry
drawLine2: 
    ; r3 = number of edgeEntries on row
	; r0 = first entry of row on edgetable
	to r5
	ldw (r0); r5 has address of textur
	with r5
	add #2 ; r0 points to start
	;
	to r8
	ldb (r0) ; r8 has start
	add #1 ; r0 points to length
	to r7
	ldb (r0) ; r7 has length
	add #1 ; r0 points to scale
	to r6
    ldw (r0) ; r6 has scale_r
	with r6
	div2 ; r6 = scale / 2 because two pixels are stored in a byte
	add #2 ; r0 points to next entry if any

    move r13, r0 ; backup next address to r13
    
	
	ibt r0, #$3 ; transparency off, high nibble has color
	cmode 
	ibt r0, #0 ; set color to black
	color

	padStart:
	  from r8
	  sub r1
	  beq drawSpriteLine
	  nop
	  bmi drawSpriteLine
	  nop
	  plot
	  bra padStart
	nop

	; r0 = scratch
	; r1 = plotX
	; r2 = plotY
	; r3 = number of edgeEntries on row
	; r4 = scratch
	; r5 = texture address
    ; r6 = scale_r
	; r7 = length
	; r8 = startX, available to scratch
	; r9 = scratch
	; r10+ scratch 
	drawSpriteLine:
		move r14, r5 ; begin prefetch
		iwt r4, #0 ; r4 will be 8.8 with integer part added to r5 as offset
	drawSpriteLine1:
	  with r4
	  add r6
	  to r9
	  from r4
	  hib
	  getc ; prefetch should be complete
	  from r5
	  to r14
	  add r9 ; load next byte

;	  with r9 
;	  ror ; is r9 odd if so, color low nibble
;	  bcs :+
;	  	ibt r0, #$5 ; transparency off, high nibble has color
;		bra drawPixel
;		nop
		ibt r0, #$5 ; transparency off, low nibble has color  
      drawPixel:
	    cmode
	    plot
	  dec r7
	  bne drawSpriteLine1
	  nop  
	dec r3
	; r0 = first entry of row on edgetable
	move r0, r13
	bne drawLine2
    nop
	; set r0 to next entry, update y pos, loop
  	ibt r6, #.sizeof(edgerow)
	inc r2
  	from r2
	umult r6
  	iwt r3, #edgeTable
	iwt r13, #drawEdgeTable  
	loop
	add r3 ; r0 = next entry in table

  	nop

finish:

	shutdown:
	rpix
	rpix
	stop
	nop
	nop
	nop

tree:
.export tree
  incbin Tree, "Data/tree.bin"

pillar:
.export pillar
  incbin Pillar, "Data/pillar.bin"

banner1:
.export  banner1
  incbin Banner1, "Data/st_banner.bin"
  
banner2:
.export  banner2
  incbin Banner2, "Data/art_banner.bin"
.segment "GSURAM"
spritespace:
  .res .sizeof(spritelist)
edgeTable:
  .res .sizeof(edgetable)

