.include "libSFX.i"
.include "edgeEntry.i"

;This draws tree.bin
; Tree.bin is 0x1f columns 
; Tree.bin is 4bpp data (two pixels per cell)
; Tree.bin is 0x3f rows

.segment "GSUCODE"
;lines = 0xA0
GSU_Code:
.export GSU_Code

createEdgeTable:
  ;for 0 -> spritespace::counter
  ; for 0 -> sprite height * scale
  ;   addEdgeEntry (sprite, startX, scale)
  ; end
  ;end

drawEdgeTable:
  ; for (row : edgeTable)
  ;  for (entry : row)
  ;    prefill_transparent (write 0 to all pixels < first startX)
  ;    drawEdgeTable

	ibt r0, #$3
	romb

	cache	
    
	lm r14, (.loword(spritespace + spritelist::sprites)); read address of sprite from sprite list
	
	ibt r2, #$FF ; plot y = -1 (roll over to zero at start of startRow)
	to r10
	getb ; first byte of image is width
	;ibt r12, #$20 ; 0x1f is the number of bytes in a row of the tree sprite
	inc r14 ; next byte is image height
	to r11
	getb ; store height to r11
	inc r14 ; next byte is image data

	; At this point r11 has height, r10 has width
	startRow:
		move r12, r10 ; set width to loop counter
	  	ibt r1, #$0; plot x = 0
		inc r2; plot y ++ (initiallialy rolls over to 0)	
		iwt r13, #drawRow 
    drawRow:
		ibt r0, #$3 ; transparency off, high nibble has color
		cmode 
	    getc
		plot
		ibt r0, #$1 ; transparency off, low nibble has color
		cmode 
		getc
		inc r14 ; prefetch next byte
		loop
		plot
	advanceLine: ; check if end
	    move r0, r11
		sub r2
		bge startRow
		nop ; instruction after jump always executed
	shutdown:
	rpix
	rpix
	stop
	nop
	nop
	nop

tree:
.export tree
  incbin Tree, "Data/tree.bin"

pillar:
.export pillar
  incbin Pillar, "Data/pillar.bin"

banner1:
.export  banner1
  incbin Banner1, "Data/st_banner.bin"
  
banner2:
.export  banner2
  incbin Banner2, "Data/art_banner.bin"
.segment "GSURAM"
spritespace:
  .res .sizeof(spritelist)
edgeTable:
  .res .sizeof(edgetable)
