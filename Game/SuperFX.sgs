.include "libSFX.i"
.include "edgeEntry.i"

;This draws tree.bin
; Tree.bin is 0x1f columns 
; Tree.bin is 4bpp data (two pixels per cell)
; Tree.bin is 0x3f rows

.segment "GSUCODE"
;lines = 0xA0
GSU_Code:
.export GSU_Code

initializeEdgeTable:
  ;set all counters to 0 in 
  cache
  iwt r12, #159
  iwt r13, #:+
  :
  ibt r0, #.sizeof(edgerow)
  umult r12
  iwt r1, #edgeTable
  to r1
  add r1
  ibt r0, #0
  stb (r1)
  loop
nop
  iwt r1, #edgeTable
  ibt r0, #0
  stb (r1)

createEdgeTable:
  ibt r0, #3 ; sprite index counter
  romb 

  ibt r5, #0 ; sprite index counter

  
  
  ;for 0 -> spritespace::count
  	iwt r0,# (spritespace + spritelist::count) ; address of number of sprites
  	to r3
  	ldb (r0) ;get number of sprites to r3
cache
    addEdgeEntry:
	; umult = r5 * r6 => [R0]
	; r5 is sprite index.
	; r6 will have size of sprite
	; spritespace + r0 => r14 which is the start of the sprite list to draw
	iwt r6, #.sizeof(sprite)
	from r6
	umult r5
	iwt r1, #(spritespace + 2)
	add r1; skip pad byte and r0 = address of address of textur
	to r14
	ldw (r0) ; r14 has address of texture and loads first byte
	
    
	; optimize we need to interleave instructions so the rom buffer can fill
	; calculate and update the count of the line index of edge entries
	;   count := (edgeTable + yLoc * sizeof(edgeentry) )
	;   yLoc = r0+3
	ibt r1, #$2
	to r1
	add r1
	to r9
	ldb (r1) ; r9 now has xLoc

	ibt r1, #$3
	to r1
	add r1
	to r6
	ldb (r1) ; r6 now has yLoc
	move r4, r6 ; r4 has yLoc
	inc r1 ; r1 + 1 = scaleAddress
	to r2
	ldw (r1); r2 has scale
	;load texture address to r0 interleaving load
	move r8, r0
	getbl
	inc r14

	ibt r7, #.sizeof(edgerow)
	with r6
	umult r7 ; r6 = yLoc* sizeof(edgerow)
	iwt r1, #edgeTable
	from r6
	to r7
	add r1; r7 = address of count
	to r6
	ldb (r7)
	to r8
	ldw(r8)

	getbh
;how many rows?
; r0[h] * r6
move r10, r6
move r6, r2
move r2, r10

to r11
hib
with r11
swap
with r11
fmult
with r11
lob	


	;end interleave
    ; r0 = [h][w/2]
	; r2 = count
	; r6 = scale
	; r3 = #ofSprites
	; r4 = yLoc
	; r5 = spriteIndex
	; r7 = count address
	; r8 = spriteAddress
	; r9 = xLoc
	; r11 = rendered height
	;============================
	;
	;
	;r8 = spriteAddress := {W/2 (bh), h(bl), 4bpp[]}
	;
	; r8+2 = xLoc
	; r8+3 = yLoc
	; r8+4/5 = scale
	;
    ; we need to write an edgeEntry from yLoc -> yLoc + (h*scale).
	;   each entry is ++count _pad_ entries[]{texture, xLoc, w*2*scale, scale}
	;write to count_address + 2 +  count*sizeof(edgeentry) the following {r8, r9, r0[low]*2*r6, r6}


addEdgeRow:
    ibt r10, #.sizeof(edgeentry)
    move r1, r0
	move r0, r2
	from r10
	umult r2
	add #2
	add r7
	from r8
	stw (r0)
	add #2
	from r9
	stb (r0)
	add #1
	to r10
	lob
	with r10
	rol
	with r10
	swap
	with r10
	fmult 
	from r10
	stb (r0)
	add #1
	from r6
	stw (r0)
	inc r2
	from r2
	stb (r7)
    move r0, r1
    ;update count
      ;update count_address
	  ; load new count
	iwt r10, #.sizeof(edgerow)
	with r7
	add r10
	to r2
	ldb (r7)
	dec r11
	bne addEdgeRow
	nop
	; this writes one edge entry 

	; for 0 -> sprite height * scale
  	;   addEdgeEntry (sprite, startX, scale)
  	; end

	inc r5
	from r3
	sub r5
	branch:
	bne addEdgeEntry
	nop
  	;TODO subtracing spriteIndex - spriteCount and branching if the index is past the count may be faster by 1 - 2cycles
  	

  ;end 
  
  

drawEdgeTable:
  ; for (row : edgeTable)
  ;  for (entry : row)
  ;    prefill_transparent (write 0 to all pixels < first startX)
  ;    drawEdgeTable

	ibt r0, #$3
	romb

	cache	
    
	lm r14, (.loword(spritespace + spritelist::sprites)); read address of sprite from sprite list
	
	ibt r2, #$FF ; plot y = -1 (roll over to zero at start of startRow)
	to r10
	getb ; first byte of image is width
	;ibt r12, #$20 ; 0x1f is the number of bytes in a row of the tree sprite
	inc r14 ; next byte is image height
	to r11
	getb ; store height to r11
	inc r14 ; next byte is image data

	; At this point r11 has height, r10 has width
	startRow:
		move r12, r10 ; set width to loop counter
	  	ibt r1, #$0; plot x = 0
		inc r2; plot y ++ (initiallialy rolls over to 0)	
		iwt r13, #drawRow 
    drawRow:
		ibt r0, #$3 ; transparency off, high nibble has color
		cmode 
	    getc
		plot
		ibt r0, #$1 ; transparency off, low nibble has color
		cmode 
		getc
		inc r14 ; prefetch next byte
		loop
		plot
	advanceLine: ; check if end
	    move r0, r11
		sub r2
		bge startRow
		nop ; instruction after jump always executed
	shutdown:
	rpix
	rpix
	stop
	nop
	nop
	nop

tree:
.export tree
  incbin Tree, "Data/tree.bin"

pillar:
.export pillar
  incbin Pillar, "Data/pillar.bin"

banner1:
.export  banner1
  incbin Banner1, "Data/st_banner.bin"
  
banner2:
.export  banner2
  incbin Banner2, "Data/art_banner.bin"
.segment "GSURAM"
spritespace:
  .res .sizeof(spritelist)
edgeTable:
  .res .sizeof(edgetable)

