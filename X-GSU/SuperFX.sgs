; SuperFX
; Summers Pittman <secondsun@gmail.com>
; 16-bit 0.16-fixed point reciprocol
; reciprocol
.include "var.sgs"
.include "libSFX.i"
.include "structs/structs.sgs"
.include "common/stack.sgs"


.macro init_camera
iwt r1, #(camera_mem + camera::eye + vector3::xPos)
	iwt r0, #$0
	stw (r1)

	iwt r1, #(camera_mem + camera::eye + vector3::yPos)
	iwt r0, #$0
	stw (r1)
	
	iwt r1, #(camera_mem + camera::eye + vector3::zPos)
	iwt r0, #$0
	stw (r1)
	
	;Create lookAt
	iwt r1, #(camera_mem + camera::lookAt + vector3::xPos)
	iwt r0, #$da33 ; -37.8 in 8.8 twos compliment fixed point
	stw (r1)

	iwt r1, #(camera_mem + camera::lookAt + vector3::yPos)
	iwt r0, #$18b3 ; 24.7 in 8.8 twos compliment fixed point
	stw (r1)
	
	iwt r1, #(camera_mem + camera::lookAt + vector3::zPos)
	iwt r0, #$1400 ; 20.0 in 8.8 twos compliment fixed point
	stw (r1)
	
	;Create up
	iwt r1, #(camera_mem + camera::up + vector3::xPos)
	iwt r0, #$0
	stw (r1)

	iwt r1, #(camera_mem + camera::up + vector3::yPos)
	iwt r0, #$0100; 1.0 in 8.8 twos compliment fixed point
	stw (r1)
	
	iwt r1, #(camera_mem + camera::up + vector3::zPos)
	iwt r0, #$0
	stw (r1)

.endmacro


.segment "GSUCODE"
GSU_Code:
.define zaxis r1
.define xaxis r2
.define yaxis r3
.define stackbackup r4



camera_demo:
	init_stack
	init_camera ; I've hardcoded eye 0,0,0 lookAt -37.8,24.7,20, up 0,1,0 
	
	;This code demonstrates a GLU lookAt
	;First we get the vectors of our three axises based on the camera's situation
	; |x| indicated the normalized vector of x
	
	;First Xaxis = |lookAt-eye| 
	
		;load camera.lookAt.x to x1
		lm r0, (camera_mem + camera::lookAt + vector3::xPos)
		;load camera.eye.x to x0
		lm r1,  (camera_mem + camera::eye + vector3::xPos)
		;subtract to r0
		sub r1
		;push to stack
		sm (vector_1), r0

		;load camera.lookAt.v to x1
		
		lm r0, (camera_mem + camera::lookAt + vector3::yPos)
		;load camera.eye.y to x0
		lm r1, (camera_mem + camera::eye + vector3::yPos)
		;subtract to r0
		sub r1
		;push to stack
		sm (vector_1 + vector3::yPos), r0
	
	;load camera.lookAt.v to x1
		lm r0, (camera_mem + camera::lookAt + vector3::zPos)
		;load camera.eye.y to x0
		lm r1, (camera_mem + camera::eye + vector3::zPos)
		;subtract to r0
		sub r1
		;push to stack
		sm (vector_1 + vector3::zPos), r0
		iwt r1, #vector_1

	;Now we can normalize the vector at r10 - #6 (a vector is 6 bytes, and we pushed those bytes to the stack; r10 is pointing at the end of the stack so we look back)
 	;call #vector_length
	link	#4
	iwt	  r15, #vector_length
	nop
 stop
	nop
	stop
	nop

;Vector.length function put in r1 the memory address of the vector to get the length of
;note this isn't going to be accurate, I drop decimals after the square operations. This isn't a
;problem for "long vectors" but is a problem for short ones.
;Right now this is used for camera functions

vector_length:
.scope VectorLenght

	gsu_stack_push r11 ; push return address to stack

	.define vec r1 ; Pointer to the vector to get the length of
	;r0 = (vec.x)
	ldw (r1)
	;square vec.x/r0
	move r6, r0
	fmult 
	move r3, r0 ; save x^2 to r3
	
	with r1
	add #2 ;r1 = vec.y
	
	;r0 = (vec.y)
	ldw (r1)
	;square vec.y/r0
	move r6, r0
	fmult 
	move r2, r0 ; save y^2 to r2
	with r1
	add #2 ;r1 = vec.z
	
	;r0 = (vec.z)
	ldw (r1)
	;square vec.z/r0
	move r6, r0
	fmult  ; r0 = z^2
	
	add r2 ; r0 = z^2 + y^2 
	add r3 ; r0 = z^2 + y^2 + x^2

	move r1, r0 ; prepare for calling gsu_sqrt with input = r1


	link	#4
	iwt	  r15, #gsu_sqrt
	nop
	gsu_stack_pop r15 ; jump to return address on stack
	nop

	;load 


.endscope
.include "gsu_maths/gsu_sqrt.sgs"

